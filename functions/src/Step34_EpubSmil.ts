import { onRequest } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import * as admin from "firebase-admin";
import JSZip from "jszip";
// @ts-ignore - xmlbuilder2 íƒ€ì… ì •ì˜ ì—†ìŒ
import { create } from "xmlbuilder2";

if (!admin.apps.length) {
    admin.initializeApp();
}

const db = admin.firestore();

interface SentenceTimestamp {
    start: number;
    end: number;
}

/**
 * XML ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜
 */
function escapeXml(s: string): string {
    return s.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
}

/**
 * íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ mm:ss í˜•ì‹ìœ¼ë¡œ ë³€í™˜
 */
function formatTimestamp(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, "0")}`;
}

/**
 * Step 34: EPUB3 Media Overlays(SMIL) + Read-Aloud ë™ê¸°í™” ìƒì„±
 * GET /generateReportEpubSmil?reportId=REPORT_ID
 */
export const generateReportEpubSmil = onRequest(
    {
        region: "asia-northeast3",
        cors: true,
    },
    async (req, res) => {
        try {
            // GET query ë˜ëŠ” POST bodyì—ì„œ reportId ê°€ì ¸ì˜¤ê¸°
            const reportId = (req.query.reportId as string) || (req.body?.reportId as string);
            
            if (!reportId) {
                res.status(400).send("reportId is required");
                return;
            }

            logger.info("ğŸ“š EPUB(SMIL) ìƒì„± ì‹œì‘:", { reportId });

            // Firestoreì—ì„œ ë¦¬í¬íŠ¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const reportDoc = await db.collection("reports").doc(reportId).get();
            
            if (!reportDoc.exists) {
                res.status(404).send("Report not found");
                return;
            }

            const reportData = reportDoc.data();
            const content = reportData?.content || reportData?.summary || "";
            const keywords = reportData?.keywords || [];
            const sentenceTimestamps: SentenceTimestamp[] = reportData?.sentenceTimestamps || [];
            const audioUrl = reportData?.audioUrl || "";

            if (!audioUrl) {
                res.status(400).send("audioUrl is required for SMIL EPUB");
                return;
            }

            if (sentenceTimestamps.length === 0) {
                res.status(400).send("sentenceTimestamps are required for SMIL EPUB");
                return;
            }

            // EPUB ë©”íƒ€ë°ì´í„°
            const title = `AI Report - ${reportId.substring(0, 8)}`;
            const author = "YAGO VIBE AI Assistant";
            const uuid = `urn:uuid:${reportId}`;

            // ë¬¸ì¥ ë¶„í• 
            const SENTENCE_SPLIT_REGEX = /(?<=[.!?ã€‚ï¼ï¼Ÿ\n|ã€‚|\.|?|!|ï¼Ÿ|ï¼|ã€‚])\s+/g;
            const sentences = content.split(SENTENCE_SPLIT_REGEX).filter(Boolean).map(s => s.trim()).filter(Boolean);

            // ì˜¤ë””ì˜¤ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
            const fetch = (await import("node-fetch")).default;
            const audioResponse = await fetch(audioUrl);
            if (!audioResponse.ok) {
                throw new Error(`Failed to download audio: ${audioResponse.statusText}`);
            }
            const audioBuffer = await audioResponse.buffer();

            // EPUB ZIP ìƒì„±
            const zip = new JSZip();

            // mimetype
            zip.file("mimetype", "application/epub+zip");

            // META-INF/container.xml
            const containerXml = create({ version: "1.0", encoding: "UTF-8" })
                .ele("container", { version: "1.0", xmlns: "urn:oasis:names:tc:opendocument:xmlns:container" })
                    .ele("rootfiles")
                        .ele("rootfile", {
                            "full-path": "OEBPS/content.opf",
                            "media-type": "application/oebps-package+xml"
                        })
                    .up()
                .up()
                .end({ prettyPrint: true });
            zip.folder("META-INF")?.file("container.xml", containerXml);

            // OEBPS í´ë”
            const oebps = zip.folder("OEBPS");

            // report.xhtml ìƒì„±
            const reportXhtml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <title>${escapeXml(title)}</title>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
    <h1 id="title">${escapeXml(title)}</h1>
    <p class="meta">Generated by ${escapeXml(author)}</p>
    ${sentences.map((s, i) => {
        const found = keywords.filter((k: string) => s.toLowerCase().includes(k.toLowerCase()));
        const keywordRegex = new RegExp(`\\b(${keywords.join("|")})\\b`, "gi");
        return `
            <section id="s-${i}" class="sent">
                <p>${escapeXml(s).replace(keywordRegex, '<span class="kw">$1</span>')}</p>
                ${found.length ? `<div>${found.slice(0, 6).map((k: string) => `<span class="chip">${escapeXml(k)}</span>`).join(" ")}</div>` : ""}
            </section>
        `;
    }).join("\n")}
</body>
</html>`;
            oebps?.file("report.xhtml", reportXhtml);

            // report.smil ìƒì„± (SMIL Media Overlays)
            const smil = create({ version: "1.0", encoding: "UTF-8" })
                .ele("smil", {
                    xmlns: "http://www.w3.org/ns/SMIL",
                    version: "3.0"
                })
                    .ele("body")
                        .ele("seq", { id: "seq1", "epub:textref": "report.xhtml" })
                            .ele("par", { id: "par-title" })
                                .ele("text", { src: "report.xhtml#title" })
                                .up()
                                .ele("audio", { src: "audio.mp3", clipBegin: "0", clipEnd: `${sentenceTimestamps[0]?.start || 0}` })
                            .up();

            sentences.forEach((s, i) => {
                const ts = sentenceTimestamps[i];
                if (!ts) return;
                
                smil
                    .ele("par", { id: `par-${i}` })
                        .ele("text", { src: `report.xhtml#s-${i}` })
                        .up()
                        .ele("audio", {
                            src: "audio.mp3",
                            clipBegin: `${ts.start}`,
                            clipEnd: `${ts.end}`
                        })
                    .up();
            });

            smil.up().up().up();
            oebps?.file("report.smil", smil.end({ prettyPrint: true }));

            // style.css
            const styleCss = `
body { font-family: "Noto Sans KR", Arial, sans-serif; line-height: 1.6; padding: 20px; }
h1 { font-size: 24px; font-weight: bold; margin: 20px 0; color: #1f2937; }
.meta { font-size: 12px; color: #6b7280; margin: 8px 0; }
.chip { display: inline-block; background: #fef3c7; color: #92400e; padding: 4px 8px; border-radius: 12px; font-size: 11px; margin: 2px; }
.kw { background: #fef3c7; color: #92400e; font-weight: bold; padding: 2px 4px; }
.sent { margin: 20px 0; padding: 12px; border-left: 3px solid #e5e7eb; }
`;
            oebps?.file("style.css", styleCss);

            // audio.mp3
            oebps?.file("audio.mp3", audioBuffer);

            // content.opf ìƒì„±
            const opf = create({ version: "1.0", encoding: "UTF-8" })
                .ele("package", {
                    xmlns: "http://www.idpf.org/2007/opf",
                    version: "3.0",
                    uniqueIdentifier: "book-id"
                })
                    .ele("metadata", { xmlns: "http://purl.org/dc/elements/1.1/" })
                        .ele("dc:title").txt(title).up()
                        .ele("dc:creator").txt(author).up()
                        .ele("dc:identifier", { id: "book-id" }).txt(uuid).up()
                        .ele("dc:language").txt("ko").up()
                        .ele("meta", { property: "dcterms:modified" }).txt(new Date().toISOString()).up()
                    .up()
                    .ele("manifest")
                        .ele("item", { id: "report", href: "report.xhtml", "media-type": "application/xhtml+xml" }).up()
                        .ele("item", { id: "style", href: "style.css", "media-type": "text/css" }).up()
                        .ele("item", { id: "audio", href: "audio.mp3", "media-type": "audio/mpeg" }).up()
                        .ele("item", { id: "smil", href: "report.smil", "media-type": "application/smil+xml", properties: "media-overlay" }).up()
                    .up()
                    .ele("spine", { toc: "nav" })
                        .ele("itemref", { idref: "report", "media-overlay": "smil" }).up()
                    .up()
                .up();
            oebps?.file("content.opf", opf.end({ prettyPrint: true }));

            // EPUB ZIP ìƒì„±
            const epubBuffer = await zip.generateAsync({ type: "nodebuffer", compression: "DEFLATE" });

            res.setHeader("Content-Type", "application/epub+zip");
            res.setHeader("Content-Disposition", `attachment; filename=AIReport_${reportId}_ReadAloud.epub`);
            res.status(200).send(epubBuffer);

        } catch (e: any) {
            logger.error("EPUB(SMIL) ìƒì„± ì˜¤ë¥˜:", e);
            res.status(500).send(e?.message || "EPUB(SMIL) generation failed");
        }
    }
);

